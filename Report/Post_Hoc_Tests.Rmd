---
title: "Post Hoc Tests From PL Model"
author: "Stats4SD"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: github_document
---

```{r setup, include=FALSE}
library("PlackettLuce")
library("gosset")

multcompPL<-function(mod,terms=NULL,threshold=0.05,Letters=letters,adjust="none"){
  
  require("qvcalc")
  require("multcompView")
  
  #get estimates with quasi-SEs
  qv1<-qvcalc(mod)$qvframe
  
  #reduce frame to only selected terms if not all comparisons are desired
  if(is.null(terms)==FALSE){
    qv1<-subset(qv1,rownames(qv1)%in%terms)
    #give error if less than 2 terms can be identified
    if(nrow(qv1)<3){
      stop("Less than 2 terms selected")
    }
  }
  
  #set up matrices for all differences and pooled errors
  diffs<-mat.or.vec(nrow(qv1),nrow(qv1))
  ses<-mat.or.vec(nrow(qv1),nrow(qv1))
  
  for(i in 1:nrow(qv1)){
    for(j in 1:nrow(qv1)){
      
      #get differences and pooled ses
      diffs[i,j]<-qv1$estimate[i]-qv1$estimate[j]
      ses[i,j]<-sqrt(qv1$quasiVar[i]+qv1$quasiVar[j])
    }
  }
  
  #calculate z scores
  z<-diffs/ses
  #TO DO: Think about what DF to use to use here? Is it just the resid DF or do I need to do some more thinking? 
  p<-2*(1-pt(abs(z),mod$df.residual))
  
  #adjust p-value if you want to adjust. make sure to only take each p once for adjustment
  p[upper.tri(p)]<-p.adjust(p[upper.tri(p)],method = adjust)
  
  #make sure lower triangular is mirror of upper
  p[lower.tri(p)] = t(p)[lower.tri(p)]
  
  #set rownames
  rownames(p)<-colnames(p)<-rownames(qv1)
  
  #re-order qv output to ensure letters are produced in a sensible order
  qv1$term<-reorder(factor(rownames(qv1)),qv1$estimate,mean)
  qv1<-qv1[order(qv1$estimate,decreasing = TRUE),]
  
  #get mean seperation letter groupings
  #use multcompLetters2 to get the order based on value
  qv1$.group<-multcompLetters2(estimate ~ term, p, qv1,
                               compare="<",
                               threshold=threshold,
                               Letters=Letters,
                               reversed = FALSE)$`Letters`
  return(qv1)
  
}

#simple ggplot function to plot output from multcompPL with error bars
#probably should update this with qt rather than qnorm once I work out what DF to use
plot.multcompPL<-function(x,level=0.95,xlab="",ylab=""){
  require(ggplot2)
  p1<- ggplot(data=x,aes(y=estimate,x=term,label=.group,ymax=estimate+qnorm(1-(1-level)/2)*quasiSE,
                         ymin=estimate-qnorm(1-(1-level)/2)*quasiSE))+
    geom_point()+
    geom_errorbar(width=0.1)+
    coord_flip()+
    geom_text(vjust=1.2)+
    xlab(ylab)+ylab(xlab)
  return(p1)
}
```

Use the breadwheat data from gosset library and fit a model as shown in the help menus.

```{r}
library(PlackettLuce)
data("breadwheat", package = "gosset")


R <- to_rankings(breadwheat,
                 items = c("variety_a","variety_b","variety_c"),
                 rankings = c("overall_best","overall_worst"),
                 type = "tricot")

mod1 <- PlackettLuce(R,  npseudo = 0, maxit = 7)
summary(mod1)
```

Then using multiple comparison functions defined above to give CLD output for estimates of model then plotting with confidence intervals and letters on graph.

Probably need to find a better word than "mean separation" here...

```{r}
mean_sep <- multcompPL(mod1)
mean_sep

plot.multcompPL(mean_sep, level = 0.84)+
  ggtitle("'Mean' Separation with 84% Confidence Intervals",
      subtitle = "Non-Overlapping Confidence Intervals can be assumed to be 'significantly' different")
```


